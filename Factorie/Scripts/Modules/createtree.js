
export function createTree(array, beforeName, afterName) {
    // Returns [[key: string, ...], ...], which is a 2D array which represents each layer in the tree.

    // 'array' is an array/dict of objects, containing at the very least an array within each object that points to names of what objects come before it
    // 'beforeName' is the name of the array within each value that indicates what values before it make it up
    // 'afterName' is an optional value that is the name of array within each value that indicates what values it creates after it (see crafting.js to understand)
    let tree = [[]];
    for (let key in array) {
        let value = array[key];
        if (value[beforeName].length && value[beforeName].length > 0) { continue; }
        else if ((!value[beforeName].length) && afterName) {
            let foundAfter = false;
            for (let inputName in value[beforeName]) {
                for (let key2 in array) {
                    let value2 = array[key2];
                    if (Object.keys(value2[afterName]).find((afterKey) => { return (afterKey == inputName); })) {
                        foundAfter = true;
                        break;
                    }
                }

                if (foundAfter) { break; }
            }
            
            if (foundAfter) { continue; }

        }// else { continue; }
        tree[0].push(key);
    }

    let currentLayer = 0;
    while (true) { // Keep going until every object has been added
        currentLayer++;
        let toPush = []
        for (let key in array) { // For every key in the array
            let value = array[key];

            let precursorsFound = [];
            let cont = false;
            let before = value[beforeName];
            let notNeeded = 0;
            if (afterName) { // If objects have after requirements
                before = Object.keys(before);
                for (let p in before) { // For every object that must come before (precursor)
                    let precursor = before[p];
                    let found = false;
                    Object.keys(array).find((key2) => { // Go through the array
                        let value2 = array[key2];
                        found = Object.keys(value2[afterName]).find((afterKey) => { // And go through each item's after objects
                            return (afterKey == precursor); // And check if they match the precursor
                        });

                        return found;
                    })

                    if (found) { continue; }
                    notNeeded++; // If there were no 'after objects' found for this precursor, reduce the needed items in the precursor list
                }
            }

            for (let l in tree) { // For each layer in the tree
                let layer = tree[l];
                if (layer.find((name) => { return (name == key); })) { cont = true; break; }
                for (let p in before) { // For each precursor
                    let precursor = before[p];
                    let found = false;
                    if (afterName) { // If objects have after requirements
                        found = layer.find((precursorName) => { // Go through the list
                            return Object.keys(array[precursorName][afterName]).find((afterKey) => { // And go through each of their after requirements
                                return (precursor == afterKey); // And check whether or not the after requirement is equal to the precursor
                            });
                        }); // If it is, that means this object in the layer comes before the main object being looked at
                    } else { // If the objects DONT have after requirements
                        found = layer.find((precursorName) => { return (precursor == precursorName); }); // Check if the precursor is found in the layer plainly
                    }

                    if (found) {
                        precursorsFound.push(precursor);
                    }
                }
            }
            
            if (cont || precursorsFound.length < (before.length - notNeeded)) { continue; }
            toPush.push(key);
        }

        if (toPush.length <= 0) { break; }
        tree.push(toPush);
    }

    return tree;
}


export function createUITree(tree, blockSize, blockSeparation, layerSeparation) {
    // Returns [
    //       [
    //        {key: string, top: number, left: number, connections: [[{x0: number, y0: number, x1: number, y1: number}], ...]},
    //    ...],
    //...], which is 2D array representing each block and its connections

    // 'tree' is the object generated by createTree()
    // 'blockSize' is the size of each individual block in the tree in the ui
    // 'blockSeparation' is the separation between each block on the same layer
    // 'layerSeparation' is the separation between each layer
    let uiTree = [];
    let layerN = 0;
    let largestWidth = 0;
    tree.forEach((layer) => {
        let itemN = 0;
        let width = 0;
        layer.forEach((item) => {
            let width = itemN * (blockSize + blockSeparation);
            if (width > largestWidth) {
                largestWidth = width;
            }
            itemN++;
        });
    });

    for (let layerKey in tree) {
        let layer = tree[layerKey];
        let itemN = 0;
        for (let itemKey in layer) {
            let item = layer[itemKey];
            uiTree.push({
                key: item,
                top: layerN * (blockSize + layerSeparation),
                left: itemN * (blockSize + blockSeparation)
            });
            itemN++;
        }
        layerN++;
    }

    return uiTree;
}